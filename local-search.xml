<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>极客时间-从0开始学微服务</title>
    <link href="/2021/10/17/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2021/10/17/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>秋招时经常面试官经常会问一个问题：你对微服务有什么理解？那么这篇文章就是对微服务架构、以及微服务中的各种组件做一个简单的学习，不会涉及具体的实现。</p><h2 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h2><h3 id="到底什么是微服务"><a href="#到底什么是微服务" class="headerlink" title="到底什么是微服务"></a>到底什么是微服务</h3><p>首先我们先来看一下微服务的定义，微服务的概念最早是在 2014 年由 Martin Fowler 和 James Lewis 共同提出，他们定义了微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 ( 例如Docker )技术，服务可以用不同的编程语言与数据库等。</p><p>这个定义比较抽象，那么接下来我会结合软件架构的演化过程来解释微服务到底是什么。</p><h3 id="软件架构的演化过程"><a href="#软件架构的演化过程" class="headerlink" title="软件架构的演化过程"></a>软件架构的演化过程</h3><ul><li>单体应用</li></ul><p>当我们的项目比较小时，我们通常会采用单体应用架构，例如MVC架构，它的优点便是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。</p><p>但是，随着业务规模逐渐扩大，开发人员不断增加，那么单体应用架构便会开始出现问题，具体体现在：部署效率低下、团队协作开发成本高、系统可用性变差、线上发布变慢等。</p><ul><li>微服务</li></ul><p>那么如何解决单体应用的问题，就出现了服务化的思想。服务化思想用通俗的话来说，就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。一般在编写业务代码时，对于一些通用的业务逻辑，我会尽力把它抽象并独立成为专门的模块，因为这对于代码复用和业务理解都大有裨益。</p><p>得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演化为今天的微服务。其特点是：服务拆分粒度更细、服务独立部署、服务独立维护、服务治理能力要求高。微服务极大地提高了应用交付的效率，并被互联网公司普遍采用。</p><h2 id="微服务到底是什么样子"><a href="#微服务到底是什么样子" class="headerlink" title="微服务到底是什么样子"></a>微服务到底是什么样子</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><p>从单体应用演化为微服务，架构发生变化，绝对不会是简简单单就演化成功，那么演化过程中会有哪些问题需要解决？首先，一个单体应用演化为多个服务，这其中服务如何进行拆分、定义，其次拆分完成后各个服务之间如何进行调用，所有服务的运行状态我们如何知道，系统中出现故障如何定位。这些问题都是微服务架构需要解决的问题。</p><h3 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h3><p>我们通过一次完整的服务调用流程来了解下微服务到底是什么样子的。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110172121275.png" alt="image-20211017212110102"></p><p>首先服务提供者按照约定的格式对自己提供的服务进行描述，并且想注册中心进行注册，完成服务的发布。接下来服务消费者通过请求注册中心，查询到需要调用的服务地址，例如ip、端口、方法名等，然后通过RPC进行调用。RPC调用过程中，服务的请求耗时、调用量以及成功率等指标都会被记录下来用作监控，调用经过的链路信息会被记录下来，用于故障定位和问题追踪。在这期间，如果调用失败，可以通过重试等服务治理手段来保证成功率。</p><p>通过以上描述，我们可以得出微服务所依赖的几个基本组件：</p><ul><li>服务实例</li><li>注册中心</li><li>RPC</li><li>服务监控</li><li>链路追踪</li><li>服务治理</li></ul><p>之前华为一面面试官问了我微服务的组件，我说了这些后面试官说还少了一个最重要的负载均衡。我个人的理解是负载均衡是一种思想而不是一个单独的组件 ，在分布式环境下，我们将一个集群对外抽象成一个节点，那么在集群内部请求如何分发，就通过负载均衡。负载均衡非常常见，在以上基本组件中都有负载均衡的影子。</p><h3 id="具体组件"><a href="#具体组件" class="headerlink" title="具体组件"></a>具体组件</h3><h4 id="服务实例"><a href="#服务实例" class="headerlink" title="服务实例"></a>服务实例</h4><p>这部分最重要的问题就是一个单体应用如何拆分以及拆分粒度问题，这个问题没有固定的答案，需要具体问题具体分析。服务拆分的姿势有两种：纵向拆分和横向拆分。</p><p>纵向拆分即从业务维度进行拆分，我个人的理解是按照系统业务模块进行拆分，可以通过DDD去指导服务的拆分。</p><p>横向拆分则是从公共且独立功能维度拆分，即标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>服务提供者和服务消费者通过RESTful API、XML 配置以及 IDL 文件三种方式对自己提供的服务或者是自己需要调用的服务进行描述，然后向注册中心注册自己的服务，服务消费者则去注册中心中获取到自己订阅的服务。注册中心就类似与我们手机上的地图App，我想去一个地点，就去App上查询地址在哪。服务消费者可以从注册中心中查询出服务的具体地址，从而发起调用。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110172122953.png" alt="image-20211017212220902"></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>服务消费者需要调用A服务，并且通过注册中心知道了A服务的地址，接下来便是发起RPC调用。一个RPC框架通常由三个部分组成：通信框架、通信协议和序列化与反序列化。通信框架主要解决的是客户端与服务器端如何建立连接，服务器端如何处理请求。通信协议是客户端与服务器端约定好的数据传输格式，通过该协议对数据进行解析。序列化与反序列化解决的则是客户端和服务端采用哪种数据编解码的问题。</p><h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p>当服务消费者能够向服务提供者发起调用，那么就需要监控RPC的调用情况，以及监控服务实例的运行状态等。主要有以下几个需要了解：监控对象、监控指标、监控维度。</p><ul><li>监控对象</li></ul><p>接口监控、资源监控、基础监控等。</p><ul><li>监控指标</li></ul><p>QPS、响应时间、错误率等。</p><ul><li>监控维度</li></ul><p>全局维度、机房维度、单机维度、时间维度、核心维度等。</p><h4 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h4><p>在微服务架构下，由于应用拆分为了多个服务，那么一次请求有可能会调用多个服务，如果这次请求失败了，想查清楚到底是哪个服务导致的失败，就需要链路追踪。同时链路追踪记录了每一次调用涉及服务的详细信息，例如耗时信息，就可以根据这些信息优化系统的瓶颈，以及优化调用链路。</p><p>核心原理是通过一个全局唯一的ID将分布在各个服务节点中的同一次请求串联起来，从而还原一次请求的调用关系。</p><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>服务监控可以发现问题，链路追踪可以定位问题，那么如何解决问题，就是服务治理。</p><p>那么服务治理的手段有哪些，常见的有一下：</p><ul><li>节点管理</li></ul><p>服务调用失败时可以对节点进行摘除，有两种机制分别是：注册中心主动摘除、服务消费者摘除。其中更合理的是将存活探测机制用在服务消费者，因为真正发起调用的是服务消费者。</p><ul><li>负载均衡</li></ul><p>概念就不说了，主要说下负载均衡的算法：随机、轮询、加权轮询、负载最低优先、性能最优、Hash类。</p><ul><li>服务路由</li></ul><p>由于存在灰度发布、多机房就近访问等需求，因此需要制定路由规则。路由规则的配置一般采用动态配置，即存到配置中心。</p><p>我的理解是如果负载均衡决定的是请求集群内的哪一台机器，那么路由就是决定请求哪一个集群。</p><ul><li>服务容错</li></ul><p>对于服务调用失败的情况，需要有一定的手段自动恢复，来保证调用成功。主要由几种：FailOver、FailBack、FailCache、FailFast。</p><ul><li>流量控制</li></ul><p>限流、熔断与降级，这三者都是流量过大时，通过一定的方式去保护系统的手段，是应对高并发的三板斧。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章主要是从原理的角度介绍了微服务，并没有从如何实现的角度。将微服务落地实际上是一个非常有难度的技术活，微服务的每一个基础组件其中都有很多门道。后续的计划则是深入学习开源的微服务组件，以及美团内部自研的组件。</p><p>参考：胡忠想-从0开始学微服务</p>]]></content>
    
    
    <categories>
      
      <category>极客时间</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间-设计模式之美</title>
    <link href="/2021/10/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    <url>/2021/10/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先从为什么要学设计模式这个问题开始。</p><p>说一说我个人的看法：在学校做项目时很少会去考虑代码如何设计，主要原因是项目比较简单。到了公司后发现，项目规模一旦大起来，系统设计、代码设计就非常重要了，同时公司的产品也在迅速迭代，这就要求了代码需要具有良好的扩展性，不能因为一个新需求然后把以前的代码全部推翻了重写。正是在公司代码中看到了许多设计模式的影子，所以才有了学习这个专栏的想法。</p><p>设计模式实际上是一个非常抽象的话题，个人感觉非常像数据结构与算法那门课，就是学了后发现和没学一样，因此这篇文章只会简单介绍一些常用的设计模式和我的一些个人理解。</p><h2 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>设计模式共23种（抽象工厂单独算一种），可分为三大类：创建型、结构型、行为型。</p><ul><li><p>创建型：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p></li><li><p>结构型：主要解决类或对象的组合问题，将类或对象组合成经典结构，这些经典结构可以解决特定应用场景的问题。</p></li><li><p>行为型：主要解决类或对象之间的交互问题。</p></li></ul><p>图上打了勾的即为常用的设计模式，下一部分只介绍打了勾的。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110092007081.png" alt="image-20211009200731998"></p><p>题外话：本来想用表格展示的，结果发现Typora不支持单元格合并，= =。。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>单例模式用来创建全局唯一的对象，某些业务场景下要求对象全局唯一，而某些场景下使用单例则可以复用对象，节约资源。单例有几种实现方式，分别是：饿汉式、懒汉式、双重检查、静态内部类、枚举，实现时我们需要关注几个点：</p><ul><li><p>对象创建时线程安全问题</p></li><li><p>是否支持延迟加载</p></li><li><p>getInstance()性能是否高（是否加锁）</p></li></ul><p>要能够说出每一种实现方式的对应以上优缺点是什么，具体实现见：<a href="https://github.com/Vice-Tone/leetcode-jin/blob/master/algorithm/Singleton.java">https://github.com/Vice-Tone/leetcode-jin/blob/master/algorithm/Singleton.java</a></p><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上如果创建对象逻辑不复杂，那我们直接new就可以了，不需要使用工厂模式，避免过度设计。当创建逻辑比较复杂时，我们可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用解耦。</p><p>工厂模式包括简单工厂、工厂方法、抽象工厂这三种细分模式，其中简单工厂和工厂方法比较常用，抽象工厂应用较少。工厂模式一个非常经典的案例：Spring IOC。</p><p>工厂模式的作用，同时也是判断要不要使用工厂模式的参考标准如下：</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><h5 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h5><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li><p>创建对象需要必填属性时，如果放在构造函数，又会面临构造函数参数列表过长的问题，如果通过set()方法，那么校验逻辑就无处安放了。</p></li><li><p>如果我们希望创建不可变对象，对象创建好后就不应该暴露set()方法。</p></li></ul><p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问， 而非加强功能，这是它跟装饰器模式最大的不同。这里实际上跟我们平时说的有点不同，平时我们常说不改变原始类，给原始类进行功能增强，可以采用代理，理解这个意思即可。</p><p>代理模式有两种，分别是静态代理和动态代理，动态代理更加灵活，用的更多。代理模式常用在业务系统中开发一些非功能性需求，比如:监控、统计、鉴权、限流、事 务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。</p><h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>个人更倾向与第一种理解方式，“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。“抽象”的所有逻辑操作，最终都委托给“实现”去执行。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110101314194.png" alt="image-20211010131415143"></p><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><p>装饰器的一个经典案例：Java IO类库。 </p><h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式:类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>举个栗子：我们现在系统依赖了一个外部系统，这个外部系统接口设计有些缺陷，我们想对外部系统提供的接口进行二次封装，这个时候就可以使用适配器模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">External</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lowPerformanceFunction2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>&#125;<br><br><span class="hljs-comment">//使用适配器模式重构</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITarget</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExternalAdaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">External</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITarget</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">super</span>.method1();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">super</span>.lowPerformanceFunction2();<br>  &#125;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>观察者模式的主要作用是将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式:有同步阻塞的实现方式，也有异步非阻塞的实现方式;有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦;异步非阻塞除了能实现代码解耦之外，还能提高代码 的执行效率;进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>举几个栗子：Spring中的事件机制、ZooKeeper的Watcher机制、Kafka监听指定topic。</p><h5 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h5><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式有两大作用:复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    method1();<br>    <span class="hljs-comment">//...</span><br>    method2();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>;<br>  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxxHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHandler</span> </span>&#123;<br>  <br>  <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>  <br>  <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br><br>AbstractHandler xxxhandler = <span class="hljs-keyword">new</span> XxxHandler(); <br>xxxhandler.handle();<br></code></pre></td></tr></table></figure><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个 策略，有两种确定方法:编译时静态确定和运行时动态确定。其中，“运行时动态确定”才 是策略模式最典型的应用场景。在实际的项目开发中，最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断（本质是借助查表法）。</p><p>策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h5 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h5><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>这个模式GoF的定义是，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递， 而是会被所有的处理器都处理一遍。</p><p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了对扩展开放、对修改关闭的设计原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerPipeline</span> </span>&#123;<br>  <br>  <span class="hljs-keyword">private</span> List&lt;IHandler&gt; handlers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHandler</span><span class="hljs-params">(IHandler handler)</span> </span>&#123; <br>    <span class="hljs-keyword">this</span>.handlers.add(handler);<br>&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (IHandler handler : handlers) &#123;<br>      handler.handle();<br>    &#125;<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h5><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由 3 个部分组成:状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，我们总结了三种实现方式。</p><p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p><p>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p><h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”、“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、 跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p><p>遍历集合一般有三种方式: for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有 3 个优势:</p><ul><li><p>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可;</p></li><li><p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一;</p></li><li><p>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p></li></ul><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方 式，让遍历操作直接抛出运行时异常。</p><p>那么删除集合元素的正确姿势有两种：</p><ul><li><p>用迭代器提供的remove操作</p></li><li><p>for循环内用index控制下标，删除元素index进行自减</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一句话，写代码时思考如何设计，但不是处处运用设计模式，避免过度设计。</p><p>目前这个专栏我已经看了两遍，收获了很多，但也还有很多东西没搞明白，后面会结合着其他网上资料，以及《大话设计模式》等继续深入学习，上面如果有说的不对的地方可以在评论区指出~</p><p>参考：王争-设计模式之美</p>]]></content>
    
    
    <categories>
      
      <category>极客时间</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇blog-为什么想做一个博客网站</title>
    <link href="/2021/10/05/%E7%AC%AC%E4%B8%80%E7%AF%87blog-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%83%B3%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/2021/10/05/%E7%AC%AC%E4%B8%80%E7%AF%87blog-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%83%B3%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么想做这样一个博客网站"><a href="#为什么想做这样一个博客网站" class="headerlink" title="为什么想做这样一个博客网站"></a>为什么想做这样一个博客网站</h3><p>今年6月-9月很幸运在美团实习了三个月，公司内部有一个云平台，公司里所有自研组件的技术文档、包括每个组的技术、需求文档、团队建设文档等，全部都在这个平台中，这个平台中的文档数量可能已经是百万甚至千万级，这就是一个公司的积累、沉淀。</p><p>前几周偶然看到一篇公众号文章，里面有一个词叫做“输出式学习”，从2020年考完研后自学技术到现在，学习了接近两年的时间，虽然一些技术已经能够熟练掌握，但是却没有任何沉淀。最近在看极客时间上的相关专栏，内容比较有挑战性，但是没有输出的话，也就只是看了一遍，看过后可能几天就忘了。在美团时我的导师和Leader也经常跟我说，要有输入，也要有输出。因此趁着国庆的期间，搭了这个网站，养成“输出式学习”的习惯。</p><p>这个博客网站主要会分享些以下内容：</p><ul><li>个人总结性文章，例如实习总结，年度总结等。</li><li>技术性文章，例如极客时间的专栏。</li><li>以图片的形式记录自己的所见所得。</li></ul><h3 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h3><p>这个网站搭起来实际上非常简单，我大概花了半天的时间，其中也碰到了一些问题。</p><p>主要步骤：</p><ul><li>1.安装各种环境：Node.js、Git、Hexo</li><li>2.将Hexo搭建好的网站部署到GitHub上</li><li>3.GitHub+PicGo图床功能</li><li>4.评论功能（待建设）</li><li>5.换主题，网站美化（待建设）</li></ul><p>注意事项：</p><ul><li>1.GitHub现在经常打不开，需要挂代理。</li><li>2.使用hexo d 命令部署时如果卡着不动，报错显示不能和GitHub用https 443端口连接上，查看hosts文件，然后把127.0.0.1的映射全注释掉，我是这么解决的。</li><li>3.用hexo搭建博客我是看了codesheep羊哥的B站视频，视频里他全程用的root账号，如果用了root账号，有可能会出现创建新博客时不能用Typora修改的情况，因为新的md文件是root创建的（hexo new 命令），个人建议是用自己账号也可以，亲测无影响。</li></ul><h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><p>简单说下最近三个月的计划。</p><p>首先是十月：</p><ul><li><p>完善这个网站，目前还比较简陋</p></li><li><p>完成秋招，十月底应该可以基本结束</p></li><li><p>面试知识带着看</p></li><li><p>极客时间持续学习，明年入职前把下面这些专栏全部学习完</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110051745365.png" alt="image-20211005174539332"></p></li></ul><p>十一月&amp;十二月，重心放在毕业工作上：</p><ul><li>专利</li><li>论文</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
