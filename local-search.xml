<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ceshi</title>
    <link href="/2023/02/19/ceshi/"/>
    <url>/2023/02/19/ceshi/</url>
    
    <content type="html"><![CDATA[<p>ceshi 2023</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回顾2021年</title>
    <link href="/2021/12/27/%E5%9B%9E%E9%A1%BE2021%E5%B9%B4/"/>
    <url>/2021/12/27/%E5%9B%9E%E9%A1%BE2021%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<p>21年马上就结束了，一晃马上研究生都要毕业了。今年收获也非常多，与去年相同，可以说是处于人生的上升期。</p><p>从去年9月份开始，除了给老师做做项目，其他时间基本都在自学。从今年年初开始准备找暑期的实习，应该是从三月初开始投的简历，美团是我投的第一家，没想到的是最后也是它给我发了实习offer。找实习的历程还是非常的曲折，甚至感觉和秋招比也差不多了，从三月找到五月一直都处在面试-等面试结果这样一个情况，然后就是面试不通过，五月初那会已经开始怀疑人生了，不过最终还是应验了那句话，功夫不负有心人。这两年来让我最开心的两件事，一个是查考研初试的分数，另一个就是收到美团实习offer。回家休息了两个星期后就出发去了北京。</p><p>记得很清楚在五月的最后一天入了职，第一次进入大公司，给我的感觉就是规范化，一切都在计划中。同时也让我感觉每个人就像一个小零件，无数个零件拼起了美团，使它能够正常运作。三个月学到了非常多的东西，不论是技术方面的，还是非技术方面的，也要感谢Leader和Mentor对我的成长培养。在北京也交到了几个好朋友。</p><p>三个月时间一晃而过，八月底实习结束后，因为禄口机场的疫情，在家待了二十多天后才回到学校。从九月开始准备秋招，秋招的过程可以说是非常不顺利，十月十五过生日那天晚上接近十点接到了美团Hr的电话，然后就决定留在美团了。工作确定后代码啥的基本就没碰了，就是看论文，做汇报，写论文。</p><ul><li>2021.1 - 2021.3 自学</li><li>2021.3 - 2021.5 找实习</li><li>2021.5 - 2021.6 休息</li><li>2021.6 - 2021.9 美团实习</li><li>2021.9 - 2021.10中 秋招</li><li>2021.10中 - 2021.12 毕业论文</li></ul><p>总的来说，这一年不像大学的前三年荒废掉了，定下了满意的工作，毕业论文进度也在正轨上。如果满分是100分的话，给自己今年的表现可以打一个85分。</p><p>技术方面感觉自己已经到了自学的瓶颈，Kafka、ES在学校用的太少，希望以后去公司后加强这方面的熟练度，以及学习更高层次的设计。相比于研发中间件的源代码，我更喜欢做系统设计层面的东西，从顶层的角度让我有一种可以了解、把控全局的感觉。而且我觉得，设计出一个人们常用的、带来实际价值的系统，它所带来的成就感要更加强烈。</p><p>非技术方面自己需要加强的主要还是职业软素质方面，这一点对于打工人来说还是非常重要的，既然是给别人打工，那就不能自己想怎么来就怎么来。保持积极主动，也是对自己的个人成长负责。</p><p>明年的话，定个小目标：顺利毕业，带父母出去旅游一趟，工作迅速融入状态。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度回顾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-代码版本控制</title>
    <link href="/2021/11/19/Git-%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/11/19/Git-%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git是每一个程序员都该会的东西，上学时虽然没有相关课程，但工作后每天都在用。如果开发时只是听别人的话敲Git命令，而不去了解原理，这样一旦出了问题，你也很难独立解决。快速的解决问题，正是学习底层原理的原因。 </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h3><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202111191508694.png" alt="image-20211119150849925"></p><h3 id="分支和HEAD"><a href="#分支和HEAD" class="headerlink" title="分支和HEAD"></a>分支和HEAD</h3><p>每一个分支就像一个链表，链表的节点是commit，<strong>分支名是一个指针（理解这个非常重要！）</strong>，指向该分支最新提交的commit。每一次commit修改的就是分支名指针的状态。</p><p>HEAD也是一个指针，通常情况下是指向分支名的，所以和分支名一样，总是指向当前分支上最近一次提交记录。HEAD代表的是我们当前所在的commit，如果我们想要修改提交树，回退版本时，一般都是通过操作HEAD指针。</p><h2 id="命令相关"><a href="#命令相关" class="headerlink" title="命令相关"></a>命令相关</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p><strong>git add</strong></p></li><li><p><strong>git commit</strong></p></li><li><p><strong>git pull</strong></p></li><li><p><strong>git push</strong></p></li><li><p><strong>git status</strong></p></li><li><p><strong>git tag</strong></p></li><li><p><strong>git log –pretty=oneline</strong> 显示所有提交过的版本信息，不包括已经被删除的 commit 记录和 reset 的操作</p></li><li><p><strong>git reflog</strong> 显示所有记录，常用于回退</p></li><li><p><strong>git branch + git checkout/switch</strong> 创建、切换分支</p></li><li><p><strong>git checkout -b /</strong> <strong>git switch -c</strong> 创建并切换分支，推荐用switch</p></li><li><p><strong>git branch -d/-D</strong> 删除分支/强行删除</p></li><li><p><strong>git stash 、 git stash apply/pop 、 git stash list</strong> 储存当前分支的修改相关命令</p></li><li><p><strong>git merge 目标分支</strong> 把目标分支合并到当前分支（重要！常用！）</p></li><li><p><strong>git rebase 目标分支</strong> 将当前分支的工作复制到目标分支，用得少（没merge用的多），-i参数为交互式</p></li><li><p><strong>git cherry-pick commitId</strong> 将指定的commit复制到当前分支（用得少）</p></li><li><p><strong>git checkout – file</strong> 丢弃工作区的修改（用得少）</p></li><li><p>**git reset HEAD file **把暂存区的修改回退到工作区（用得少）</p></li><li><p>**git reset –hard HEAD^ **已经commit了，版本回退。参数说明–hard丢弃工作区的修改，–soft保留工作区修改</p></li><li><p><strong>git remote add origin git地址</strong> 关联远程仓库，origin是远程库默认命名</p></li><li><p>**git remote -v **查看远程库信息</p></li><li><p><strong>git remote rm origin</strong> 解除关联的远程库</p></li><li><p><strong>git config –global alias.co checkout</strong> 设置别名</p></li></ul><h3 id="命令中需要注意的参数"><a href="#命令中需要注意的参数" class="headerlink" title="命令中需要注意的参数"></a>命令中需要注意的参数</h3><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>merge有三种模式，fast-forward、–no-ff、–squash</p><p>fast-forward：当条件允许的时候，git直接把HEAD指针指向需要合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支（没操作过，不过感觉这操作挺危险），则会丢失分支信息，因为在这个过程中没有创建commit。条件允许是啥意思，举个例子：新建了一个bugFix分支，然后在这个分支上提交了两次，然后要把bugFix合并到main，而main分支这个期间没有新的commit，Git就会用fast-forward。</p><p>–no-ff：不使用fast-forward方式合并，每一次合并都会创建一次commit。</p><p>–squash：使用squash方式合并，把多次分支commit历史压缩为一次（基本没用过）。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202111221056822.png" alt="img"></p><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p><strong>reset</strong>也有三种参数：**–hard、–soft、–mixed**。</p><p><strong>reset</strong>的本质行为并不是撤销，而是移动 <strong>HEAD</strong> ，并且「捎带」上 <strong>HEAD</strong> 所指向的 <strong>branch</strong>（如果有的话</p><p><strong>–hard</strong>：**–hard** 会在重置 <strong>HEAD</strong> 和<strong>branch</strong>的同时，重置stage区和工作目录里的内容，你的stage区和工作目录里的内容会被完全重置为和<strong>HEAD</strong>的新位置相同的内容。换句话说，就是还没有commit的修改会被全部删除（属于危险操作）。</p><p><strong>–soft</strong>：在重置 <strong>HEAD</strong> 和 <strong>branch</strong> 时，保留工作目录和暂存区中的内容，并把重置 <strong>HEAD</strong> 所带来的新的差异放进暂存区。举个例子：</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202111221124028.png" alt="未命名绘图"></p><p><strong>–mixed</strong>：默认参数，同soft，只不过是清空暂存区，保存到了工作目录。所以效果看起来就是原节点和<strong>reset</strong>节点之间的所有差异都会放到工作目录中。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="场景一：标准开发流程"><a href="#场景一：标准开发流程" class="headerlink" title="场景一：标准开发流程"></a>场景一：标准开发流程</h3><p>代码仓库新建分支，然后pull到本地，切换过去开发，开发完成后，要切换回本地的master分支pull一下，因为这段时间别人可能上线了新需求，本地的master已经落后了。然后将master分支合并到开发分支，这样开发分支就是最新的分支。最后push，提PR。</p><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>场景描述：现在我正在开发一个需求，开发到了一半，代码写到一半我不想commit，这个时候有另一个更急的需求。我们需要切换到另一个分支，这时候发现切换到的新分支上显示了上一个需求还没写完的代码。</p><p>解决方法：使用<strong>git stash</strong>命令存储修改，把较急的需求完成后在切换回来，使用<strong>git stash pop</strong>命令恢复。<strong>git stash list</strong>命令则可以查看我们暂存了哪些修改。</p><h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p>场景描述：如果代码已经push到远程了，如何回退到上一个版本。</p><p>解决方法1：先在本地用<strong>git reset –hard HEAD^</strong>回退到指定版本，然后<strong>git push -f</strong>，这个方法有一定风险，**-f**参数强制push有可能会把别人的代码覆盖，慎用。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202111201533311.gif" alt="2021-11-20 15.32.50"></p><p>解决方法2：<strong>git revert HEAD</strong>，这个命令的意思是，通过一次新的commit将HEAD所在的commit抵消掉，然后push到远程即可，注意：revert指定版本有可能会冲突，不推荐使用。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202111201535459.gif" alt="2021-11-20 15.34.09"></p><h3 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h3><p>后续更新中。。。。。。。。。</p>]]></content>
    
    
    <categories>
      
      <category>技术专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacBook提升效率的方法</title>
    <link href="/2021/11/07/MacBook%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2021/11/07/MacBook%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在互联网公司开发一般配的都是Macbook Pro，这个电脑如果你只是听别人说多好用，不用鼠标触控板就行啥的，我估计之前没用过的人上手的感觉应该是也就那样（除了不卡）。一台全新的Macbook Pro只能算一个艺术品（这也是我当年的第一感觉，做工完美的像一个艺术品，这很苹果），只有你花点心思在这个电脑上，它才会成为一件生产力工具。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>command+c/v/a</strong>    复制/粘贴/全选（后面的command简写为cmd）</p><p><strong>cmd+delete</strong>    删除当前行，选中文件时删除文件</p><p><strong>shift+方向键</strong>    多选</p><p><strong>cmd+shift+左右方向键</strong>    以左方向键为例：选择当前行开头到光标的位置</p><p><strong>cmd+Tab</strong>    切换应用，但是我很少用，后面我会说我的切换应用的方式</p><p><strong>cmd+`</strong>    切换同一应用的窗口，用在Finder很舒服</p><p><strong>cmd+w/q</strong>    关闭当前窗口（应用在后台还没关，常用的一般也不用关）/关闭应用</p><p><strong>cmd+t/n</strong>    新建tab/新建窗口</p><p><strong>cmd+i</strong>    显示文件简介，用得不多</p><p><strong>空格键</strong>    大部分文件都能用，预览文件，好用</p><p>IDEA的快捷键就不列了，实在是太多了，而且最近没怎么写代码有点忘了 = = 。。。</p><h2 id="好用的App"><a href="#好用的App" class="headerlink" title="好用的App"></a>好用的App</h2><p>![image-20211107210816350](/Users/jin/Library/Application Support/typora-user-images/image-20211107210816350.png)</p><p>提升效率的App我主要装了上面这些，有的不是，下面挑几个介绍介绍</p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>相比自带的Spotlight，Alfred可以定制各种各样workFlow，只要你肯花心思，他啥都能实现。</p><p>唤醒的快捷键我设置的cmd+space。</p><p>这个软件我主要用在两个方面：</p><ul><li>有道翻译的workFlow，唤醒后输入yd，接个空格，后面跟要翻译的</li><li>找文件，唤醒后输入find，接个空格，后面跟文件名</li></ul><h3 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h3><p>截图软件，这个软件我最常用的功能是贴图功能，就是截图后，把截图钉在屏幕上，快捷键可自定义。</p><p>唯一缺点不能滚动截图、长截图。</p><h3 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h3><p>显示剪切板历史，快捷键我设的<strong>cmd+shift+v</strong>，好用。</p><h3 id="Scroll-Reverser"><a href="#Scroll-Reverser" class="headerlink" title="Scroll Reverser"></a>Scroll Reverser</h3><p>当你接了鼠标后，突然发现滚轮的方向怎么反了？？？原因就是触控板的方向和滚轮方向相反，这里有个有意思的点，触控板两指滑动的逻辑是，苹果把屏幕当成一个画布，这样方向就跟我们想的一样了。</p><p>这个软件可以反转鼠标的滚轮，然后就跟你想的一样了。</p><h3 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a>iTerm</h3><p>自带终端的替代品，提供更强的自定义功能。</p><p>总之一点，用自定义功能时一定要搞清楚原理是什么，比如说你把shell换成了zsh，那你就要知道环境变量应该配在.zshrc这个文件里。</p><h3 id="BetterTouchTool"><a href="#BetterTouchTool" class="headerlink" title="BetterTouchTool"></a>BetterTouchTool</h3><p><strong>重点！！！好用！！！</strong></p><h4 id="全屏工作法"><a href="#全屏工作法" class="headerlink" title="全屏工作法"></a>全屏工作法</h4><p>我个人习惯将应用全屏化,例如浏览器、IDEA、Typora等，将应用全屏最大的好处在于避免注意力被其他的信息分散掉。</p><p>然而应用打开时一般都不是全屏的，鼠标移到左上角再点一下太慢，如何快速进入全屏，就借助BetterTouchTool，设置触控板五指轻点，进入全屏。</p><p>接下来的问题就是如何切换应用，因为全屏只能显示一个应用。触控板四指左右轻扫，这个系统设置里就有。</p><h4 id="Finder相关设置"><a href="#Finder相关设置" class="headerlink" title="Finder相关设置"></a>Finder相关设置</h4><p>Finder平时用的实在是太多了，因此我设置了一个全局快捷键，<strong>cmd+e</strong>打开Finder。进入Finder后显示哪个目录也是可以设置的，一般设置成下载就挺好，另外将常用的目录放在Finder的侧边栏，很好用。</p><h4 id="自定义快捷键启动App"><a href="#自定义快捷键启动App" class="headerlink" title="自定义快捷键启动App"></a>自定义快捷键启动App</h4><p>我只设置了一个<strong>cmd+r</strong>运行iTerm。</p><p>个人感觉快捷键cmd+xxx这种方式按的最舒服，cmd+shift+xxx还行，cmd+option/control+xxx这种就比较麻烦了，目前左手这边的键盘都设了快捷键，基本够用，后续有常用的再设置。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一台新的Macbook Pro在生产力方面打分我只给打及格分，但是通过自己的自定义，则可以提升至90分。Mac上的App都是些比较小众的，得花点精力找一找🧐。推荐两个App网站：</p><ul><li><p><a href="https://xclient.info/">https://xclient.info/</a></p></li><li><p><a href="https://www.macwk.com/">https://www.macwk.com/</a></p></li></ul><p>多探索，就会发现很多可以提升效率的方法。</p>]]></content>
    
    
    <categories>
      
      <category>提效</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacBook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>书-Java8实战</title>
    <link href="/2021/10/26/%E4%B9%A6-Java8%E5%AE%9E%E6%88%98/"/>
    <url>/2021/10/26/%E4%B9%A6-Java8%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在去美团实习之前，实际上自己使用Java8的特性很少，印象中只有几次在项目代码里用了Stream流，后来到了公司后发现代码里非常多的流操作和Lambda表达式，如果不是之前学过新特性估计就跟看天书一样。Java8提供的新特性用处非常多，因此最近通过《Java8实战》这本书来巩固下Lambda、Stream流、新的日期API等知识点。</p><p>注重思想，API忘了可以再查。</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h3 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h3><p>在软件工程中，一个众所周知的问题就是，不管你做什么，用户的需求肯定会变。比方说， 有个应用程序是帮助农民了解自己的库存的。这位农民可能想有一个查找库存中所有绿色苹果的功能。但到了第二天，他可能会告诉你：“其实我还想找出所有重量超过150克的苹果。”又过了两天，农民又跑回来补充道：“要是我可以找出所有既是绿色，重量也超过150克的苹果，那就太棒了。”你要如何应对这样不断变化的需求？理想的状态下，应该把你的工作量降到最少。此外，类似的新功能实现起来还应该很简单，而且易于长期维护。</p><p>行为参数化就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。这个代码块以后可以被你程序的其他部分调用，这意味着你可以推迟这块代码的执行。例如，你可以将代码块作为参数传递给另一个方法，稍后再去执行它。这样，这个方法的行为就基于那块代码被参数化了。例如，如果你要处理一个集合， 可能会写一个方法：可以对列表中的每个元素做“某件事”。行为参数化说的就是这个，将“某件事”通过参数传进去。</p><p>上代码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Apple&gt; <span class="hljs-title">filterGreenApples</span><span class="hljs-params">(List&lt;Apple&gt; inventory)</span> </span>&#123;<br>  List&lt;Apple&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <br>  <span class="hljs-keyword">for</span>(Apple apple: inventory)&#123; <br>    <span class="hljs-keyword">if</span>( <span class="hljs-string">&quot;green&quot;</span>.equals(apple.getColor() ) &#123; <br>      result.add(apple);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 第二版，加了一个功能，可以筛选重量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Apple&gt; <span class="hljs-title">filterApplesByWeight</span><span class="hljs-params">(List&lt;Apple&gt; inventory, <span class="hljs-keyword">int</span> weight)</span> </span>&#123; <br>  List&lt;Apple&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <br>  For (Apple apple: inventory)&#123; <br>    <span class="hljs-keyword">if</span> ( apple.getWeight() &gt; weight )&#123; <br>      result.add(apple); <br>    &#125; <br>  &#125; <br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 这个时候我们发现了问题，我们不可能用户每提一个需求就来修改代码，违反开闭原则，同时我们还在copy代码</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第三版，这个时候行为参数化就派上了用场</span><br><span class="hljs-comment">// 我们将筛选苹果封装为一个参数，然后传给filterApples方法，其实就是策略模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplePredicate</span></span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span> <span class="hljs-params">(Apple apple)</span></span>; <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleHeavyWeightPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>&#123; <br>    <span class="hljs-keyword">return</span> apple.getWeight() &gt; <span class="hljs-number">150</span>; <br>  &#125; <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleGreenColorPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;green&quot;</span>.equals(apple.getColor()); <br>  &#125; <br>&#125;<br><span class="hljs-comment">// filterApples方法接受多种行为（或策略）作为参数，并在内部使用，从而完成不同的行为</span><br><span class="hljs-comment">// filterApples方法的行为取决于我们通过ApplePredicate对象传递的代码，因此我们实现了filterApples方法的行为参数化。多种行为，一个参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Apple&gt; <span class="hljs-title">filterApples</span><span class="hljs-params">(List&lt;Apple&gt; inventory, ApplePredicate p)</span></span>&#123; <br>  List&lt;Apple&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">for</span>(Apple apple: inventory)&#123;<br>    <span class="hljs-keyword">if</span>(p.test(apple))&#123;<br>      result.add(apple); <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 现在我们的代码足够灵活了，有新的需求时，我们只需要定义一个ApplePredicate接口的实现类即可</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110280012306.png"></p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110280013228.png" alt="image-20211028001324169"></p><h3 id="使用匿名内部类-amp-Lambda简化代码"><a href="#使用匿名内部类-amp-Lambda简化代码" class="headerlink" title="使用匿名内部类 &amp; Lambda简化代码"></a>使用匿名内部类 &amp; Lambda简化代码</h3><p>我们再看下上面第三版的代码还有什么可优化的点。上面每一种苹果筛选的策略代码比较简单，都只有一行，然而我们却定义了很多实现类，需要通过接口实例，把代码包裹在ApplePredicate对象里，才能将筛选苹果的行为传递到filterApples方法。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110280014944.png" alt="image-20211028001403889"></p><p>Java则提供了一种机制：匿名内部类。使用匿名内部类的filterApples方法调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Apple&gt; redApples = filterApples(inventory, <span class="hljs-keyword">new</span> ApplePredicate() &#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple a)</span></span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;red&quot;</span>.equals(a.getColor());<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>对于匿名内部类来说，你发现问题了没，仍然有很多骨架代码是不必的。</p><p>实际上我们真正关注的就是test方法的行为，因此我们是不是可以直接将test方法的行为直接传给filterApples方法。即将test方法作为参数传递到filterApples方法，将方法（函数）作为和对象相同的一等公民，这就是Lambda，通过Lambda传递方法。</p><p>个人感觉Lambda和匿名内部类很像，是匿名内部类的一种简化形式，通过反编译后我们会发现Lambda底层原理还是实现接口，传递接口实例，也即Lambda整个表达式是函数式接口的一个实例。</p><p>使用Lambda后filterApples方法调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简洁明了</span><br>List&lt;Apple&gt; result = filterApples(inventory,(Apple apple) -&gt; apple.getWeight() &gt; <span class="hljs-number">150</span>);<br></code></pre></td></tr></table></figure><p>最后我们还可以利用泛型，将ApplePredicate接口改为ApplePredicate<T>,使其抽象化，这个不是重点。</p><p><strong>再次提醒下，如果每种策略的实现逻辑比较复杂，那么还是应该采用策略模式。</strong></p><h3 id="再到方法引用"><a href="#再到方法引用" class="headerlink" title="再到方法引用"></a>再到方法引用</h3><p>既然有了函数式编程的思想，方法（函数）已经被我们看做和对象相等的一等公民，对象有对象引用，那么方法就有方法引用。</p><p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。这样更加简洁，通过恰当的方法名，代码的可读性也更好，同时还可以复用方法。个人理解可以把方法引用看做是Lambda的语法糖。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110280035144.png" alt="image-20211028003552088"></p><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><strong>Java8的重头戏！！！建议阅读原书</strong></p><h3 id="集合和流"><a href="#集合和流" class="headerlink" title="集合和流"></a>集合和流</h3><p>Collection集合是我们平时最常用的API，这个没毛病。集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素。但流的目的在于表达计算，即对集合中的元素做什么操作。集合讲的是数据，流讲的是计算。</p><p>我们平时通过for-each遍历集合，这称为外部迭代。相反，Stream使用内部迭代，它帮我们把迭代做了，内部既可以基于串行，也可以基于并行，发挥多核CPU的优势，它还把得到的流值存在了某个地方，我们只要给出一个函数说要干什么就可以了，即使用了声明性的方式来处理数据。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110280116684.png" alt="image-20211028011644616"></p><h3 id="流的一些特点"><a href="#流的一些特点" class="headerlink" title="流的一些特点"></a>流的一些特点</h3><ul><li>流水线：很多流操作本身会返回一个流，这样多个操作就可以链接起来，实现复杂逻辑。</li><li>内部迭代：上面说了。</li><li>按需计算：流就像是一个延迟创建的集合，只有在消费者要求的时候才会计算值。</li><li>只能遍历一次：流只能遍历一次，遍历完之后，我们就说这个流已经被消费掉了。 你可以从原始数据源那里再获得一个新的流来重新遍历一遍。</li></ul><h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>这一部分不是针对小白，因此需要一些前置知识。话不多说，直接上图：</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110280120986.png" alt="image-20211028012045922"></p><p>主要可以分成两类操作，中间操作和终端操作。中间操作返回值为一个新的流，相反只要返回值不是流，那么就是终端操作，终端操作的返回值通常为集合，或是一个值。每一步操作传递的都是一个函数式接口，因此常和Lambda搭配使用。</p><p>常用的操作我就不举例子了，下面举的例子都是我不太熟的一些操作。</p><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>流的扁平化，第一次碰见这个搞了好久才明白 = =。</p><p>需求：给定单词列表 [“Hello”,”World”]，返回列表[“H”,”e”,”l”, “o”,”W”,”r”,”d”]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">words.stream()<br>   .map(s -&gt; s.split(<span class="hljs-string">&quot;&quot;</span>))<br>   .flatMap(Arrays::stream)<br>     .distinct<br>     .collect(toList);<br></code></pre></td></tr></table></figure><p>flatMap相当于对流中的每个元素应用map，并生成单独的一个流，最后将所有流连接起来。</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>需求：给定一个数字集合，求出总和、最大值、最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = numbers.stream().reduce(<span class="hljs-number">0</span>, (a, b) -&gt; a + b);<br><br>Optional&lt;Integer&gt; max = numbers.stream().reduce((x, y) -&gt; x &gt; y ? x : y);<br>Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);<br><br>Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);<br></code></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>collect操作的参数为一个Collector接口，因此我们需要传一个Collector接口的实现类，实际中常用Collectors类的静态工厂方法。</p><p>主要有三大类：</p><ul><li>第一类：广义的reducing操作，和上面的reduce差不多，感觉功能更多点。</li><li>第二类：分组、分区操作，结果是一个Map。</li><li>第三类：返回一个集合，toList、toSet、toMap等等。</li></ul><p>还有其他的可以去看Collectors类的源码。</p><h3 id="关于并行流"><a href="#关于并行流" class="headerlink" title="关于并行流"></a>关于并行流</h3><p>由于内部迭代的特点，我们并不需要关注迭代具体如何实现的。将stream方法换成parallelStream即可实现并行流，不需要其他任何操作。底层原理是fork/join框架。</p><p><strong>But ！！！But ！！！But ！！！</strong></p><ul><li>并不是任何的流操作使用并行流就一定更快，并行的行为和性能有时是违反直觉的，因此一定要测试，测试，再测试！</li><li>流中元素数量特别多时并行流才逐渐展现优势，多到什么样的数量级，这个没有定论，得看你流中的元素的复杂度。</li><li>从性能角度来看，使用正确的数据结构，如尽可能利用原始流而不是一般化的流，避免频繁的装箱拆箱操作，几乎总是比尝试并行化某些操作更为重要。</li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>相信NPE是我们遇到的最多的问题。如何解决NPE，最直观的思路就是加个判断。但是当对象嵌套多层时，它让我们的代码充斥着深度嵌套的null检查，代码的可读性变差。</p><p>那么Java8的做法就是引入Optional类。一个Optional<T>类型的对象，它有可能包含了一个T类型的对象，也有可能不包含。因此Optional类显式的提醒了程序员，这个里面有可能是null。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110280048637.png" alt="image-20211028004840572"></p><p>不过Optional类我使用的挺少的。。。。在美团的时候主要的做法还是直接判断。</p><p>下面总结判空的各种方法：</p><ul><li>obj != null</li><li>Objects.nonNull ( list )</li><li>后续补充中……</li></ul><h2 id="日期API"><a href="#日期API" class="headerlink" title="日期API"></a>日期API</h2><p>实习期间做过一个需求，需要将传入的时间段参数按周维度切分，且如果开始时间为周三，则将开始时间往前推到这一周的第一天，结束时间同理。这个需求当时用新的日期API完成的，日期操作的代码量大概就是四五行，总体感觉就是新的API简洁明了、容易使用，个人强烈推荐！</p><p>以下总结一些常用的API，以便以后查询。有的方法一看方法名就知道是干啥的就不做解释了。</p><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LocalDate，只包含日期，不包含时间</span><br><span class="hljs-comment">// 当前日期</span><br>LocalDate now = LocalDate.now();<br><span class="hljs-comment">// 指定日期</span><br>LocalDate date = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">10</span>, <span class="hljs-number">27</span>);<br>LocalDate date = LocalDate.parse(<span class="hljs-string">&quot;2014-03-18&quot;</span>);<br><span class="hljs-comment">// 获取年、月、日、周、当前月的天数、是否闰年...</span><br><span class="hljs-keyword">int</span> year = date.getYear();<br>Month month = date.getMonth();<br><span class="hljs-keyword">int</span> dayOfMonth = date.getDayOfMonth();<br>DayOfWeek dayOfWeek = date.getDayOfWeek();<br><span class="hljs-keyword">int</span> lengthOfMonth = date.lengthOfMonth();<br><span class="hljs-keyword">boolean</span> leapYear = date.isLeapYear();<br></code></pre></td></tr></table></figure><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LocalTime，只包含时间，不包含日期</span><br>LocalTime now = LocalTime.now();<br>LocalTime time = LocalTime.of(<span class="hljs-number">13</span>, <span class="hljs-number">45</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">// 与LocalDate.parse()相同，你可以为parse()传一个DateTimeFormatter，来指定日期字符串的格式</span><br>LocalTime time = LocalTime.parse(<span class="hljs-string">&quot;13:45:20&quot;</span>);<br><span class="hljs-keyword">int</span> hour = time.getHour();<br><span class="hljs-keyword">int</span> minute = time.getMinute();<br><span class="hljs-keyword">int</span> second = time.getSecond();<br></code></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LocalDateTime，包含日期和时间</span><br>LocalDateTime dt1 = LocalDateTime.of(<span class="hljs-number">2021</span>, Month.OCTOBER, <span class="hljs-number">27</span>, <span class="hljs-number">13</span>, <span class="hljs-number">45</span>, <span class="hljs-number">20</span>);<br>LocalDateTime dt1 = LocalDateTime.parse(<span class="hljs-string">&quot;2021-10-28 23:59:59&quot;</span>);<br><span class="hljs-comment">// 由LocalDate和LocalDateTime合并</span><br>LocalDateTime dt2 = LocalDateTime.of(date, time);<br><span class="hljs-comment">// 转化</span><br><span class="hljs-comment">// LocalDate =&gt; LocalDateTime</span><br>LocalDateTime dt3 = date.atTime(<span class="hljs-number">13</span>, <span class="hljs-number">45</span>, <span class="hljs-number">20</span>);<br>LocalDateTime dt4 = date.atTime(time);<br><span class="hljs-comment">// LocalTime =&gt; LocalDateTime</span><br>LocalDateTime dt5 = time.atDate(date);<br><span class="hljs-comment">// LocalDateTime =&gt; LocalDate</span><br>LocalDate date = dt1.toLocalDate();<br><span class="hljs-comment">// LocalDateTime =&gt; LocalTime</span><br>LocalTime time = dt1.toLocalTime();<br></code></pre></td></tr></table></figure><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Instant 时间戳</span><br><span class="hljs-comment">// 注意：Instant区分时区信息</span><br>Instant now = Instant.now().atZone(ZoneId.systemDefault()).toInstant();<br><span class="hljs-comment">// 秒</span><br><span class="hljs-keyword">long</span> epochSecond = now.getEpochSecond();<br><span class="hljs-comment">// 毫秒</span><br><span class="hljs-keyword">long</span> epochMilli = now.toEpochMilli();<br><span class="hljs-comment">// LocalDateTime =&gt; Instant</span><br>LocalDateTime localDateTime = LocalDateTime.now();<br>Instant now = localDateTime.atZone(ZoneId.systemDefault()).toInstant();<br><span class="hljs-comment">// Instant =&gt; LocalDateTime</span><br>Instant now = Instant.now();<br>LocalDateTime dt = LocalDateTime.ofInstant(now, ZoneId.systemDefault());<br></code></pre></td></tr></table></figure><h3 id="Duration-amp-Period"><a href="#Duration-amp-Period" class="headerlink" title="Duration &amp; Period"></a>Duration &amp; Period</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Duration Period 计算两个时间之间的差值</span><br><span class="hljs-comment">// Duration基于时间，即秒，纳秒</span><br>Duration d1 = Duration.between(localtime1, localtime2);<br>Duration d1 = Duration.between(localdateTime1, localdateTime2);<br>Duration d2 = Duration.between(instant1, instant2);<br><span class="hljs-keyword">long</span> seconds = d1.getSeconds();<br><span class="hljs-keyword">int</span> nano = d1.getNano();<br><span class="hljs-comment">// Period基于日期，即天数，月数</span><br>Period period = Period.between(LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">10</span>, <span class="hljs-number">18</span>), LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">10</span>, <span class="hljs-number">28</span>));<br><span class="hljs-keyword">int</span> days = period.getDays();<br><span class="hljs-keyword">int</span> months = period.getMonths();<br></code></pre></td></tr></table></figure><h3 id="日期对象操作"><a href="#日期对象操作" class="headerlink" title="日期对象操作"></a>日期对象操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果你已经有了一个对象，你想对其进行操作，下面以LocalDate为例，LocalDateTime基本同理</span><br><span class="hljs-comment">// 使用withAttribute方法</span><br>LocalDate date1 = LocalDate.of(<span class="hljs-number">2014</span>, <span class="hljs-number">3</span>, <span class="hljs-number">18</span>); <br>LocalDate date2 = date1.withYear(<span class="hljs-number">2011</span>); <br>LocalDate date3 = date2.withDayOfMonth(<span class="hljs-number">25</span>); <br>LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, <span class="hljs-number">9</span>);<br><span class="hljs-comment">// 使用加减法</span><br>LocalDate date1 = LocalDate.of(<span class="hljs-number">2014</span>, <span class="hljs-number">3</span>, <span class="hljs-number">18</span>); <br>LocalDate date2 = date1.plusWeeks(<span class="hljs-number">1</span>); <br>LocalDate date3 = date2.minusYears(<span class="hljs-number">3</span>); <br>LocalDate date4 = date3.plus(<span class="hljs-number">6</span>, ChronoUnit.MONTHS);<br><span class="hljs-comment">// 使用TemporalAdjuster中的静态工厂方法实现更复杂的操作</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.time.temporal.TemporalAdjusters.*;<br>LocalDate date1 = LocalDate.of(<span class="hljs-number">2014</span>, <span class="hljs-number">3</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 当前日期的前一个星期日（重要！！！）</span><br><span class="hljs-comment">// 通过这两个方法即可完成我上面说的按周维度切分时间的需求</span><br>LocalDate date2 = date1.with(previousOrSame(DayOfWeek.MONDAY));<br>LocalDate date2 = date1.with(nextOrSame(DayOfWeek.MONDAY));<br><span class="hljs-comment">// 本月的最后一天</span><br>LocalDate date3 = date2.with(lastDayOfMonth());<br></code></pre></td></tr></table></figure><h3 id="日期格式化与输出"><a href="#日期格式化与输出" class="headerlink" title="日期格式化与输出"></a>日期格式化与输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 日期格式化</span><br><span class="hljs-comment">// 使用parse方法还可以指定日期字符串的格式，以LocalDateTime为例</span><br>LocalDateTime dt1 = LocalDateTime.parse(<span class="hljs-string">&quot;2021-10-28 23:59:59&quot;</span>);<br><span class="hljs-comment">// 指定自己想要的格式</span><br>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>LocalDateTime dt1 = LocalDateTime.parse(<span class="hljs-string">&quot;2021-10-28 23:59:59&quot;</span>, formatter);<br><span class="hljs-comment">// 日期时间 =&gt; 字符串</span><br>LocalDateTime now = LocalDateTime.now();<br>String nowText = now.format(formatter);<br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结：注重思想，然后多练，熟能生巧。</p><p>参考：《Java8实战》</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间-从0开始学微服务</title>
    <link href="/2021/10/17/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2021/10/17/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>秋招时经常面试官经常会问一个问题：你对微服务有什么理解？那么这篇文章就是对微服务架构、以及微服务中的各种组件做一个简单的学习，不会涉及具体的实现。</p><h2 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h2><h3 id="到底什么是微服务"><a href="#到底什么是微服务" class="headerlink" title="到底什么是微服务"></a>到底什么是微服务</h3><p>首先我们先来看一下微服务的定义，微服务的概念最早是在 2014 年由 Martin Fowler 和 James Lewis 共同提出，他们定义了微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 ( 例如Docker )技术，服务可以用不同的编程语言与数据库等。</p><p>这个定义比较抽象，那么接下来我会结合软件架构的演化过程来解释微服务到底是什么。</p><h3 id="软件架构的演化过程"><a href="#软件架构的演化过程" class="headerlink" title="软件架构的演化过程"></a>软件架构的演化过程</h3><ul><li>单体应用</li></ul><p>当我们的项目比较小时，我们通常会采用单体应用架构，例如MVC架构，它的优点便是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。</p><p>但是，随着业务规模逐渐扩大，开发人员不断增加，那么单体应用架构便会开始出现问题，具体体现在：部署效率低下、团队协作开发成本高、系统可用性变差、线上发布变慢等。</p><ul><li>微服务</li></ul><p>那么如何解决单体应用的问题，就出现了服务化的思想。服务化思想用通俗的话来说，就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。一般在编写业务代码时，对于一些通用的业务逻辑，我会尽力把它抽象并独立成为专门的模块，因为这对于代码复用和业务理解都大有裨益。</p><p>得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演化为今天的微服务。其特点是：服务拆分粒度更细、服务独立部署、服务独立维护、服务治理能力要求高。微服务极大地提高了应用交付的效率，并被互联网公司普遍采用。</p><h2 id="微服务到底是什么样子"><a href="#微服务到底是什么样子" class="headerlink" title="微服务到底是什么样子"></a>微服务到底是什么样子</h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><p>从单体应用演化为微服务，架构发生变化，绝对不会是简简单单就演化成功，那么演化过程中会有哪些问题需要解决？首先，一个单体应用演化为多个服务，这其中服务如何进行拆分、定义，其次拆分完成后各个服务之间如何进行调用，所有服务的运行状态我们如何知道，系统中出现故障如何定位。这些问题都是微服务架构需要解决的问题。</p><h3 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h3><p>我们通过一次完整的服务调用流程来了解下微服务到底是什么样子的。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110172121275.png" alt="image-20211017212110102"></p><p>首先服务提供者按照约定的格式对自己提供的服务进行描述，并且想注册中心进行注册，完成服务的发布。接下来服务消费者通过请求注册中心，查询到需要调用的服务地址，例如ip、端口、方法名等，然后通过RPC进行调用。RPC调用过程中，服务的请求耗时、调用量以及成功率等指标都会被记录下来用作监控，调用经过的链路信息会被记录下来，用于故障定位和问题追踪。在这期间，如果调用失败，可以通过重试等服务治理手段来保证成功率。</p><p>通过以上描述，我们可以得出微服务所依赖的几个基本组件：</p><ul><li>服务实例</li><li>注册中心</li><li>RPC</li><li>服务监控</li><li>链路追踪</li><li>服务治理</li></ul><p>之前华为一面面试官问了我微服务的组件，我说了这些后面试官说还少了一个最重要的负载均衡。我个人的理解是负载均衡是一种思想而不是一个单独的组件 ，在分布式环境下，我们将一个集群对外抽象成一个节点，那么在集群内部请求如何分发，就通过负载均衡。负载均衡非常常见，在以上基本组件中都有负载均衡的影子。</p><h3 id="具体组件"><a href="#具体组件" class="headerlink" title="具体组件"></a>具体组件</h3><h4 id="服务实例"><a href="#服务实例" class="headerlink" title="服务实例"></a>服务实例</h4><p>这部分最重要的问题就是一个单体应用如何拆分以及拆分粒度问题，这个问题没有固定的答案，需要具体问题具体分析。服务拆分的姿势有两种：纵向拆分和横向拆分。核心的思想都是“高内聚低耦合”。</p><p>纵向拆分即从业务维度进行拆分，我个人的理解是按照系统业务模块进行拆分，可以通过DDD去指导服务的拆分。</p><p>横向拆分则是从公共且独立功能维度拆分，即标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>服务提供者和服务消费者通过RESTful API、XML 配置以及 IDL 文件三种方式对自己提供的服务或者是自己需要调用的服务进行描述，然后向注册中心注册自己的服务，服务消费者则去注册中心中获取到自己订阅的服务。注册中心就类似与我们手机上的地图App，我想去一个地点，就去App上查询地址在哪。服务消费者可以从注册中心中查询出服务的具体地址，从而发起调用。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110172122953.png" alt="image-20211017212220902"></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>服务消费者需要调用A服务，并且通过注册中心知道了A服务的地址，接下来便是发起RPC调用。一个RPC框架通常由三个部分组成：通信框架、通信协议和序列化与反序列化。通信框架主要解决的是客户端与服务器端如何建立连接，服务器端如何处理请求。通信协议是客户端与服务器端约定好的数据传输格式，通过该协议对数据进行解析。序列化与反序列化解决的则是客户端和服务端采用哪种数据编解码的问题。</p><h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p>当服务消费者能够向服务提供者发起调用，那么就需要监控RPC的调用情况，以及监控服务实例的运行状态等。主要有以下几个需要了解：监控对象、监控指标、监控维度。</p><ul><li>监控对象</li></ul><p>接口监控、资源监控、基础监控等。</p><ul><li>监控指标</li></ul><p>QPS、响应时间、错误率等。</p><ul><li>监控维度</li></ul><p>全局维度、机房维度、单机维度、时间维度、核心维度等。</p><h4 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h4><p>在微服务架构下，由于应用拆分为了多个服务，那么一次请求有可能会调用多个服务，如果这次请求失败了，想查清楚到底是哪个服务导致的失败，就需要链路追踪。同时链路追踪记录了每一次调用涉及服务的详细信息，例如耗时信息，就可以根据这些信息优化系统的瓶颈，以及优化调用链路。</p><p>核心原理是通过一个全局唯一的ID将分布在各个服务节点中的同一次请求串联起来，从而还原一次请求的调用关系。</p><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>服务监控可以发现问题，链路追踪可以定位问题，那么如何解决问题，就是服务治理。</p><p>那么服务治理的手段有哪些，常见的有一下：</p><ul><li>节点管理</li></ul><p>服务调用失败时可以对节点进行摘除，有两种机制分别是：注册中心主动摘除、服务消费者摘除。其中更合理的是将存活探测机制用在服务消费者，因为真正发起调用的是服务消费者。</p><ul><li>负载均衡</li></ul><p>概念就不说了，主要说下负载均衡的算法：随机、轮询、加权轮询、负载最低优先、性能最优、Hash类。</p><ul><li>服务路由</li></ul><p>由于存在灰度发布、多机房就近访问等需求，因此需要制定路由规则。路由规则的配置一般采用动态配置，即存到配置中心。</p><p>我的理解是如果负载均衡决定的是请求集群内的哪一台机器，那么路由就是决定请求哪一个集群。</p><ul><li>服务容错</li></ul><p>对于服务调用失败的情况，需要有一定的手段自动恢复，来保证调用成功。主要由几种：FailOver、FailBack、FailCache、FailFast。</p><ul><li>流量控制</li></ul><p>限流、熔断与降级，这三者都是流量过大时，通过一定的方式去保护系统的手段，是应对高并发的三板斧。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章主要是从原理的角度介绍了微服务，并没有从如何实现的角度。将微服务落地实际上是一个非常有难度的技术活，微服务的每一个基础组件其中都有很多门道。后续的计划则是深入学习开源的微服务组件，以及美团内部自研的组件。</p><p>参考：胡忠想-从0开始学微服务</p>]]></content>
    
    
    <categories>
      
      <category>极客时间</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客时间-设计模式之美</title>
    <link href="/2021/10/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    <url>/2021/10/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先从为什么要学设计模式这个问题开始。</p><p>说一说我个人的看法：在学校做项目时很少会去考虑代码如何设计，主要原因是项目比较简单。到了公司后发现，项目规模一旦大起来，系统设计、代码设计就非常重要了，同时公司的产品也在迅速迭代，这就要求了代码需要具有良好的扩展性，不能因为一个新需求然后把以前的代码全部推翻了重写。正是在公司代码中看到了许多设计模式的影子，所以才有了学习这个专栏的想法。</p><p>设计模式实际上是一个非常抽象的话题，个人感觉非常像数据结构与算法那门课，就是学了后发现和没学一样，因此这篇文章只会简单介绍一些常用的设计模式和我的一些个人理解。</p><h2 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>设计模式共23种（抽象工厂单独算一种），可分为三大类：创建型、结构型、行为型。</p><ul><li><p>创建型：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p></li><li><p>结构型：主要解决类或对象的组合问题，将类或对象组合成经典结构，这些经典结构可以解决特定应用场景的问题。</p></li><li><p>行为型：主要解决类或对象之间的交互问题。</p></li></ul><p>图上打了勾的即为常用的设计模式，下一部分只介绍打了勾的。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110092007081.png" alt="image-20211009200731998"></p><p>题外话：本来想用表格展示的，结果发现Typora不支持单元格合并，= =。。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>单例模式用来创建全局唯一的对象，某些业务场景下要求对象全局唯一，而某些场景下使用单例则可以复用对象，节约资源。单例有几种实现方式，分别是：饿汉式、懒汉式、双重检查、静态内部类、枚举，实现时我们需要关注几个点：</p><ul><li><p>对象创建时线程安全问题</p></li><li><p>是否支持延迟加载</p></li><li><p>getInstance()性能是否高（是否加锁）</p></li></ul><p>要能够说出每一种实现方式的对应以上优缺点是什么，具体实现见：<a href="https://github.com/Vice-Tone/leetcode-jin/blob/master/algorithm/Singleton.java">https://github.com/Vice-Tone/leetcode-jin/blob/master/algorithm/Singleton.java</a></p><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上如果创建对象逻辑不复杂，那我们直接new就可以了，不需要使用工厂模式，避免过度设计。当创建逻辑比较复杂时，我们可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用解耦。</p><p>工厂模式包括简单工厂、工厂方法、抽象工厂这三种细分模式，其中简单工厂和工厂方法比较常用，抽象工厂应用较少。工厂模式一个非常经典的案例：Spring IOC。</p><p>工厂模式的作用，同时也是判断要不要使用工厂模式的参考标准如下：</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><h5 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h5><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li><p>创建对象需要必填属性时，如果放在构造函数，又会面临构造函数参数列表过长的问题，如果通过set()方法，那么校验逻辑就无处安放了。</p></li><li><p>如果我们希望创建不可变对象，对象创建好后就不应该暴露set()方法。</p></li></ul><p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问， 而非加强功能，这是它跟装饰器模式最大的不同。这里实际上跟我们平时说的有点不同，平时我们常说不改变原始类，给原始类进行功能增强，可以采用代理，理解这个意思即可。</p><p>代理模式有两种，分别是静态代理和动态代理，动态代理更加灵活，用的更多。代理模式常用在业务系统中开发一些非功能性需求，比如:监控、统计、鉴权、限流、事 务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。</p><h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>个人更倾向与第一种理解方式，“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。“抽象”的所有逻辑操作，最终都委托给“实现”去执行。</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110101314194.png" alt="image-20211010131415143"></p><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><p>装饰器的一个经典案例：Java IO类库。 </p><h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式:类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>举个栗子：我们现在系统依赖了一个外部系统，这个外部系统接口设计有些缺陷，我们想对外部系统提供的接口进行二次封装，这个时候就可以使用适配器模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">External</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lowPerformanceFunction2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>&#125;<br><br><span class="hljs-comment">//使用适配器模式重构</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITarget</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExternalAdaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">External</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITarget</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">super</span>.method1();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">super</span>.lowPerformanceFunction2();<br>  &#125;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>观察者模式的主要作用是将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式:有同步阻塞的实现方式，也有异步非阻塞的实现方式;有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦;异步非阻塞除了能实现代码解耦之外，还能提高代码 的执行效率;进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>举几个栗子：Spring中的事件机制、ZooKeeper的Watcher机制、Kafka监听指定topic。</p><h5 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h5><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式有两大作用:复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    method1();<br>    <span class="hljs-comment">//...</span><br>    method2();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>;<br>  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxxHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHandler</span> </span>&#123;<br>  <br>  <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>  <br>  <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br><br>AbstractHandler xxxhandler = <span class="hljs-keyword">new</span> XxxHandler(); <br>xxxhandler.handle();<br></code></pre></td></tr></table></figure><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个 策略，有两种确定方法:编译时静态确定和运行时动态确定。其中，“运行时动态确定”才 是策略模式最典型的应用场景。在实际的项目开发中，最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断（本质是借助查表法）。</p><p>策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h5 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h5><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>这个模式GoF的定义是，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递， 而是会被所有的处理器都处理一遍。</p><p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了对扩展开放、对修改关闭的设计原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHandler</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerPipeline</span> </span>&#123;<br>  <br>  <span class="hljs-keyword">private</span> List&lt;IHandler&gt; handlers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHandler</span><span class="hljs-params">(IHandler handler)</span> </span>&#123; <br>    <span class="hljs-keyword">this</span>.handlers.add(handler);<br>&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (IHandler handler : handlers) &#123;<br>      handler.handle();<br>    &#125;<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h5><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由 3 个部分组成:状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，我们总结了三种实现方式。</p><p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p><p>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p><h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”、“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、 跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p><p>遍历集合一般有三种方式: for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有 3 个优势:</p><ul><li><p>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可;</p></li><li><p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一;</p></li><li><p>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p></li></ul><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方 式，让遍历操作直接抛出运行时异常。</p><p>那么删除集合元素的正确姿势有两种：</p><ul><li><p>用迭代器提供的remove操作</p></li><li><p>for循环内用index控制下标，删除元素index进行自减</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结一句话，写代码时思考如何设计，但不是处处运用设计模式，避免过度设计。</p><p>目前这个专栏我已经看了两遍，收获了很多，但也还有很多东西没搞明白，后面会结合着其他网上资料，以及《大话设计模式》等继续深入学习，上面如果有说的不对的地方可以在评论区指出~</p><p>参考：王争-设计模式之美</p>]]></content>
    
    
    <categories>
      
      <category>极客时间</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇blog-为什么想做一个博客网站</title>
    <link href="/2021/10/05/%E7%AC%AC%E4%B8%80%E7%AF%87blog-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%83%B3%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/2021/10/05/%E7%AC%AC%E4%B8%80%E7%AF%87blog-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%83%B3%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么想做这样一个博客网站"><a href="#为什么想做这样一个博客网站" class="headerlink" title="为什么想做这样一个博客网站"></a>为什么想做这样一个博客网站</h3><p>今年6月-9月很幸运在美团实习了三个月，公司内部有一个云平台，公司里所有自研组件的技术文档、包括每个组的技术、需求文档、团队建设文档等，全部都在这个平台中，这个平台中的文档数量可能已经是百万甚至千万级，这就是一个公司的积累、沉淀。</p><p>前几周偶然看到一篇公众号文章，里面有一个词叫做“输出式学习”，从2020年考完研后自学技术到现在，学习了接近两年的时间，虽然一些技术已经能够熟练掌握，但是却没有任何沉淀。最近在看极客时间上的相关专栏，内容比较有挑战性，但是没有输出的话，也就只是看了一遍，看过后可能几天就忘了。在美团时我的导师和Leader也经常跟我说，要有输入，也要有输出。因此趁着国庆的期间，搭了这个网站，养成“输出式学习”的习惯。</p><p>这个博客网站主要会分享些以下内容：</p><ul><li>个人总结性文章，例如实习总结，年度总结等。</li><li>技术性文章，例如极客时间的专栏。</li><li>以图片的形式记录自己的所见所得。</li></ul><h3 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h3><p>这个网站搭起来实际上非常简单，我大概花了半天的时间，其中也碰到了一些问题。</p><p>主要步骤：</p><ul><li>1.安装各种环境：Node.js、Git、Hexo</li><li>2.将Hexo搭建好的网站部署到GitHub上</li><li>3.GitHub+PicGo图床功能</li><li>4.评论功能（待建设）</li><li>5.换主题，网站美化（待建设）</li></ul><p>注意事项：</p><ul><li>1.GitHub现在经常打不开，需要挂代理。</li><li>2.使用hexo d 命令部署时如果卡着不动，报错显示不能和GitHub用https 443端口连接上，查看hosts文件，然后把127.0.0.1的映射全注释掉，我是这么解决的。</li><li>3.用hexo搭建博客我是看了codesheep羊哥的B站视频，视频里他全程用的root账号，如果用了root账号，有可能会出现创建新博客时不能用Typora修改的情况，因为新的md文件是root创建的（hexo new 命令），个人建议是用自己账号也可以，亲测无影响。</li></ul><h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><p>简单说下最近三个月的计划。</p><p>首先是十月：</p><ul><li><p>完善这个网站，目前还比较简陋</p></li><li><p>完成秋招，十月底应该可以基本结束</p></li><li><p>面试知识带着看</p></li><li><p>极客时间持续学习，明年入职前把下面这些专栏全部学习完</p><p><img src="https://raw.githubusercontent.com/Vice-Tone/imageRepo/master/img/202110051745365.png" alt="image-20211005174539332"></p></li></ul><p>十一月&amp;十二月，重心放在毕业工作上：</p><ul><li>专利</li><li>论文</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
